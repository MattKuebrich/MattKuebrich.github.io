<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Relabi</title>
  <link href="https://fonts.googleapis.com/css2?family=Fragment+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Fragment Mono', monospace;
      background: #fff;
      color: #000;
      text-align: center;
      padding: 2rem;
      padding-top: 0;
      max-width: 1200px;
      margin: 0 auto;
    }
    a:link {
    color:#66f;
    }
    a:visited {
    color:#66f;
    }

    h4 {
        font-size: 0.85rem;
    }

    .lfo hr {
      margin: 1rem 0 !important;
      border: 1px dashed lightgrey;
    }
    canvas {
      display: block;
      margin: 0rem auto;
      background: #fff;
      border: 1px solid lightgrey;
    }
    label {
      display: block;
      margin-top: 0.5em;
      color: #000;
      font-size: 0.75rem;
    }
    input[type=range], select, input[type=number] {
      width: 125px;
      background: #f1f1f1;
      border: 1px solid #ccc;
      color: #000;
    }
    .control-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      gap: 1rem;
    }
    .global-controls {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1.5rem;
      width: 100%;
      padding: 1rem;
      border: 0px solid black;
      border-radius: 0.5rem;
      margin-bottom: 0rem;
      background: white;
    }
    .global-control-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      min-width: 200px;
    }
    .control-buttons {
      display: flex;
      gap: 1rem;
      margin-top: 0.5rem;
    }

    .lfo input[type=range] {
      width: 90px; /* Reduced from 125px (or default) */
    }

    .lfo-controls {
      display: flex;
        justify-content: space-evenly; /* Distribute space evenly */
      gap: 0rem;
      flex-wrap: wrap;
      width: 100%;
    }
    .lfo {
      background: #ffffff;
      border: 0px solid black;
      padding: 1rem;
      padding-top: 0rem;
      border-radius: 0.2rem;
      width: 210px;
      text-align: left;
      color: #000;
    }
    .threshold-sliders {
      text-align: left;
    }
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      height: 0.2px;
      border-radius: 0px;
      background: #ccc;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        height: 0.7rem;
        width: 0.7rem;
        border-radius: 50%;
        background: #eee;
        border: 1px solid #777;
    }

    input[type="range"]::-moz-range-thumb {
        height: 0.6rem;
        width: 0.6rem;
        border-radius: 50%;
        background: #eee;
        border: 1px solid #777;
    }

    input[type="range"]::-webkit-slider-runnable-track {
        background: transparent;
        border: none;
        box-shadow: none;
    }

    input[type="range"]::-moz-range-track {
        background: transparent;
        border: none;
        box-shadow: none;
    }

    input[type=number] {
      font-size: 0.7rem !important;     /* Smaller font */
      width: 50px;
      background: #ffffff;
      border: 1px solid #ccc;
      color: #000;
      padding-right: 0; /* Remove right padding */

    }
    select {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        font-family: 'Fragment Mono', monospace;
        font-size: 0.7rem !important;       /* Smaller font */
        border: 1px solid #ccc !important;  /* Light border */
        background: #fff !important;        /* White background */
        padding: 2px !important;            /* Tight padding */
        margin-right: -6px !important;      /* Adjust spacing */
        width: auto !important;             /* Let width adjust to content */
    }
    .lfo-controls select, .lfo-controls input[type=number] {
      margin-top: 4px;
    }
    .lfo label {
      margin-bottom: 0.5em;
    }
    .muteText {
      font-size: 1.0em;
      display: inline;
    }
    button {
      font-family: 'Fragment Mono', monospace;
      font-size: 0.75rem;
      padding: 0.5rem 1rem;
      background: #f1f1f1;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #e5e5e5;
    }
    #playPauseBtn {
      min-width: 80px;
      background:white;
      color: black;
      border: 1px solid black;
    }
    #playPauseBtn:hover {
      background: #e5e5e5;
    }
    #randomizeBtn {
      background:white;
      color: black;
      border: 1px solid black;
    }
    #randomizeBtn:hover {
      background: #e5e5e5;
    }
    .sample-select {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .sample-select select {

    }
    .lfo-title-1 { color: #66f; }
    .lfo-title-2 { color: lightgrey; }
    .lfo-title-3 { color: grey; }
    .lfo-title-4 { color: black; }
    .checkbox-row {
      margin-bottom: 8px;
    }
    hr {
      border-top: 0.5px solid black;
      width: 100%;
    }
    .corner-button {
      position: fixed;
      background: none;
      border: 1px solid black;
      width: 2rem;
      height: 2rem;
      font-size: 1rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      text-decoration: none;
      color: inherit;
      border-radius: 4px;
    }

    .corner-button:hover {
      background: #e5e5e5;
    }

    #helpButton {
      bottom: 2rem;
      left: 2rem;
    }
    #backButton {
      bottom: 2rem;
      right: 2rem;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }
    .modal-content {
      font-size: 0.75rem;
      background-color: white;
      margin: 5% auto;
      padding: 2rem;
      width: 90%;
      max-width: 700px;
      border: 1px solid black;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
      position: relative;
      max-height: 80vh;
      overflow-y: auto;
      text-align:left;
    }
    .close-button {
      position: absolute;
      right: 1rem;
      top: 0.5rem;
      font-size: 1.5rem;
      cursor: pointer;
    }
  </style>
</head>
<body>


<div style="padding-top: 10px; font-size: 0.8rem; color:#66f;">Relabi Drum Machine</div>
  <div class="control-panel">
    <div class="global-controls">
      <div class="global-control-group">
        <div class="control-buttons">
          <button id="playPauseBtn">Play</button>
          <button id="randomizeBtn">Randomize</button>
        </div>
      </div>

      <div class="global-control-group">
        <label>↑ Threshold:
          <input type="range" id="topThreshold" min="-5" max="5" step="0.1" value="0.5">
          <input type="number" id="topThresholdNum" min="-5" max="5" step="0.1" value="0.5">
        </label>
        <label>↓ Threshold:
          <input type="range" id="bottomThreshold" min="-5" max="5" step="0.1" value="-0.5">
          <input type="number" id="bottomThresholdNum" min="-5" max="5" step="0.1" value="-0.5">
        </label>
      </div>
      <div class="global-control-group">
              <label>Global Speed
                <input type="range" id="globalRate" min="0.1" max="10" step="0.1" value="1">
                <input type="number" id="globalRateNum" min="0.1" max="10" step="0.1" value="1">
              </label>
            </div>
    </div>

    <canvas id="waveCanvas" width="600" height="150"></canvas>

    <div class="lfo-controls" id="lfoControlPanel"></div>
  </div>

  <button id="helpButton" class="corner-button">?</button>
  <!-- <a class="corner-button" href="/" id="backButton">←</a> -->

  <div id="helpModal" class="modal">
    <div class="modal-content">
      <span class="close-button" id="closeModal">&times;</span>
      <div class="modal-body">
        <p><strong>About Relabi Drum Machine:</strong></p>
        <i>
        "Relabi is any compelling, coordinated-seeming structure that is built up from a pulse or grid that is unstable in a way inherently difficult for human beings to grasp. For that reason, it can be said that in lived experience Relabi is a network of events grounded on a determinate pulse that “self-erases.” The experience therefore produces a sustained sense of contradiction—of a pulse and of the simultaneous absence, the complete diffusion, of that pulse."
<p></p>
        ― John Berndt, <a href="https://johnberndt.org/relabi/Relabi_essay.htm">“Relabi”: Patterns of the Self-Erasing Pulse</a>
</i>
        <p></p>
        This drum machine is inspired by Berndt's essay above, as well as the <a href="https://www.addacsystem.com/en/products/modules/addac400-series/addac405">ADDAC System VC Relabi Generator</a> Eurorack module.
         <p></p>
         The general idea is that four LFOs are combined to create a complex "Relabi Wave." A top and bottom threshold are set, and when the wave passes through them, a sample is triggered.
         <p></p>
        Some info that might not be clear from just looking at the UI.<br>
        <ul>
        <li>The <b>"Trigger On"</b> settings controls when a drum trigger happens. Triggers occur when the waveform crosses the upper (↑) or lower (↓) threshold on a rising edge (>), falling edge (<), or at both thresholds on either edge.
        If you set the same "Trigger On" settings to multiple LFOs, the samples will happen at the same time, although this can be varied by turning down the <b>Probability</b>.
        </li>
        <li>
        <p></p>
        <b>XMod</b> uses the previous LFO as a modulation source.
        </li>
        </ul>
<p></p>
       This project is by <a href="https://github.com/MattKuebrich" target="_blank">Matt Kuebrich</a> as a contribution to the <a href="https://10kdrummachines.com/">10,000 Drum Machines</a> series.</p>
      </div>
    </div>
  </div>

  <script>
    // Performance optimized version based on sr34.html techniques

    // Audio context and buffer management
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const audioBuffers = {};
    const samples = [
      'kick', 'snare', 'hihat', 'clap', 'tom', 'rimshot',
      'cowbell', 'cymbal', 'shaker', 'tambourine', 'woodblock',
      'conga', 'bongo', 'triangle', 'cabasa', 'maracas'
    ];

    // Pre-load all audio samples
        async function loadAudioBuffers() {
          for (const sample of samples) {
            const response = await fetch(`samples/${sample}.wav`);
            const arrayBuffer = await response.arrayBuffer();
            audioBuffers[sample] = await ctx.decodeAudioData(arrayBuffer);
          }
        }

    // Initialize audio on first user interaction
    document.addEventListener('click', () => {
      if (ctx.state === 'suspended') {
        ctx.resume();
      }
    }, { once: true });

    // UI elements
    const topThreshold = document.getElementById('topThreshold');
    const topThresholdNum = document.getElementById('topThresholdNum');
    const bottomThreshold = document.getElementById('bottomThreshold');
    const bottomThresholdNum = document.getElementById('bottomThresholdNum');
    const globalRate = document.getElementById('globalRate');
    const globalRateNum = document.getElementById('globalRateNum');
    const randomizeBtn = document.getElementById('randomizeBtn');
    const waveCanvas = document.getElementById('waveCanvas');
    const waveCtx = waveCanvas.getContext('2d');

    // Link number inputs with range sliders
    topThreshold.addEventListener('input', () => topThresholdNum.value = topThreshold.value);
    topThresholdNum.addEventListener('input', () => topThreshold.value = topThresholdNum.value);
    bottomThreshold.addEventListener('input', () => bottomThresholdNum.value = bottomThreshold.value);
    bottomThresholdNum.addEventListener('input', () => bottomThreshold.value = bottomThresholdNum.value);
    globalRate.addEventListener('input', () => globalRateNum.value = globalRate.value);
    globalRateNum.addEventListener('input', () => globalRate.value = globalRateNum.value);

    // LFO state
    let phase = [0, 0, 0, 0];
    let freq = [1, 0.25, 0.33, 0.13];
    let gain = [1, 0.8, 0.6, 0.5];
    let phaseOffset = [0, 0, 0, 0];
    let crossMod = [0, 0, 0, 0];
    let waveformType = [0, 0, 0, 0]; // 0=sine, 1=square, 2=saw, 3=triangle, 4=noise
    let audioMute = [false, false, false, false];
    let lfoDisable = [false, false, false, false];
    let mode = [0, 1, 2, 3];
    let sampleIndex = [0, 1, 2, 3];
    let sample = [0, 0, 0, 0];
    let probability = [100, 100, 100, 100]; // Default to 100% probability

    const sampleLabels = [
      'Kick', 'Snare', 'Hi-hat', 'Clap', 'Tom', 'Rimshot',
      'Cowbell', 'Cymbal', 'Shaker', 'Tambourine', 'Woodblock',
      'Conga', 'Bongo', 'Triangle', 'Cabasa', 'Maracas'
    ];

    const drumColors = ['#66F', 'lightgrey', 'grey', 'black'];
    const modeLabels = ['> ↑ threshold', '< ↑ threshold', '> ↓ threshold', '< ↓ threshold', '↑↓ threshold'];
    const lfoTitleClasses = ['lfo-title-1', 'lfo-title-2', 'lfo-title-3', 'lfo-title-4'];

    // Build LFO controls with event delegation
    function buildLFOControls() {
      const lfoPanel = document.getElementById('lfoControlPanel');
      lfoPanel.innerHTML = '';

      for (let i = 0; i < 4; i++) {
        const section = document.createElement('div');
        section.className = 'lfo';

        const sampleOptions = samples.map((sample, idx) =>
          `<option value="${idx}" ${sampleIndex[i] === idx ? 'selected' : ''}>${sampleLabels[idx]}</option>`
        ).join('');

        const modeOptions = modeLabels.map((label, idx) =>
          `<option value="${idx}" ${mode[i] === idx ? 'selected' : ''}>${label}</option>`
        ).join('');

        section.innerHTML = `
          <h4 class="${lfoTitleClasses[i]}">LFO ${i+1}/h4>
          <label>Waveform:
            <select data-type="waveform" data-index="${i}">
              <option value="0" ${waveformType[i] === 0 ? 'selected' : ''}>Sine</option>
              <option value="1" ${waveformType[i] === 1 ? 'selected' : ''}>Square</option>
              <option value="2" ${waveformType[i] === 2 ? 'selected' : ''}>Saw</option>
              <option value="3" ${waveformType[i] === 3 ? 'selected' : ''}>Triangle</option>
              <option value="4" ${waveformType[i] === 4 ? 'selected' : ''}>Noise</option>
            </select>
          </label>
          <label>Gain: <input type="range" min="0" max="2" step="0.01" value="${gain[i]}" data-type="gain" data-index="${i}">
            <input type="number" min="0" max="2" step="0.01" value="${gain[i]}" data-type="gain-num" data-index="${i}"></label>
          <label>Freq: <input type="range" min="0" max="10" step="0.01" value="${freq[i]}" data-type="freq" data-index="${i}">
            <input type="number" min="0" max="10" step="0.01" value="${freq[i]}" data-type="freq-num" data-index="${i}"></label>
          <label>XMod: <input type="range" min="0" max="100" step="1" value="${crossMod[i]}" data-type="xmod" data-index="${i}">
            <input type="number" min="0" max="100" step="1" value="${crossMod[i]}" data-type="xmod-num" data-index="${i}"></label>

          <div class="checkbox-row">
            <label><input type="checkbox" data-type="disable-lfo" data-index="${i}" ${lfoDisable[i] ? 'checked' : ''}>
            <div class="muteText"> Disable LFO</div></label>
          </div>

          <hr>
          <label>Sample:
            <select data-type="sample" data-index="${i}">
              ${sampleOptions}
            </select>
          </label>

            <label><input type="checkbox" data-type="mute" data-index="${i}" ${audioMute[i] ? 'checked' : ''}>
            <div class="muteText"> Mute Sound</div></label>

          <label>Trigger On:
            <select data-type="mode" data-index="${i}">
              ${modeOptions}
            </select>
          </label>
          <label>Prob %
            <input type="range" min="0" max="100" step="1" value="${probability[i]}" data-type="probability" data-index="${i}">
            <input type="number" min="0" max="100" step="1" value="${probability[i]}" data-type="probability-num" data-index="${i}">
          </label>

        `;
        lfoPanel.appendChild(section);
      }

      // Single event listener for all LFO controls
      lfoPanel.addEventListener('input', handleLFOCtrlInput);
      lfoPanel.addEventListener('change', handleLFOCtrlChange);
    }

    function handleLFOCtrlInput(e) {
      if (!e.target.dataset || !e.target.dataset.type) return;

      const idx = parseInt(e.target.dataset.index);
      const type = e.target.dataset.type;
      const value = e.target.value;

      switch(type) {
        case 'gain':
          gain[idx] = parseFloat(value);
          updateLinkedNumberInput(`[data-type='gain-num'][data-index='${idx}']`, value);
          break;
        case 'gain-num':
          gain[idx] = parseFloat(value);
          updateLinkedRangeInput(`[data-type='gain'][data-index='${idx}']`, value);
          break;
        case 'freq':
          freq[idx] = parseFloat(value);
          updateLinkedNumberInput(`[data-type='freq-num'][data-index='${idx}']`, value);
          break;
        case 'freq-num':
          freq[idx] = parseFloat(value);
          updateLinkedRangeInput(`[data-type='freq'][data-index='${idx}']`, value);
          break;
        case 'xmod':
          crossMod[idx] = parseFloat(value);
          updateLinkedNumberInput(`[data-type='xmod-num'][data-index='${idx}']`, value);
          break;
        case 'xmod-num':
          crossMod[idx] = parseFloat(value);
          updateLinkedRangeInput(`[data-type='xmod'][data-index='${idx}']`, value);
          break;
        case 'waveform':
          waveformType[idx] = parseInt(value);
          break;
        case 'mode':
          mode[idx] = parseInt(value);
          break;
        case 'sample':
          sampleIndex[idx] = parseInt(value);
          break;
        case 'probability':
          probability[idx] = parseFloat(value);
          updateLinkedNumberInput(`[data-type='probability-num'][data-index='${idx}']`, value);
          break;
        case 'probability-num':
          probability[idx] = parseFloat(value);
          updateLinkedRangeInput(`[data-type='probability'][data-index='${idx}']`, value);
          break;
      }
    }

    function handleLFOCtrlChange(e) {
      if (!e.target.dataset || !e.target.dataset.type) return;

      const type = e.target.dataset.type;
      const idx = parseInt(e.target.dataset.index);

      if (type === 'mute') {
        audioMute[idx] = e.target.checked;
      } else if (type === 'disable-lfo') {
        lfoDisable[idx] = e.target.checked;
        if (!isPlaying) {
          initializeWaveformPreview();
        }
      }
    }

    function updateLinkedNumberInput(selector, value) {
      const el = document.querySelector(selector);
      if (el) el.value = value;
    }

    function updateLinkedRangeInput(selector, value) {
      const el = document.querySelector(selector);
      if (el) el.value = value;
    }

    // Waveform generation with caching
    const waveformCache = {};

    function sineWave(phase) {
      return Math.sin(phase);
    }

    function squareWave(phase) {
      return Math.sin(phase) >= 0 ? 1 : -1;
    }

    function sawWave(phase) {
      const normalizedPhase = (phase % (2 * Math.PI)) / (2 * Math.PI);
      return (normalizedPhase * 2) - 1;
    }

    function triangleWave(phase) {
      const normalizedPhase = (phase % (2 * Math.PI)) / (2 * Math.PI);
      return normalizedPhase < 0.5 ?
        4 * normalizedPhase - 1 :
        3 - 4 * normalizedPhase;
    }

    // Pre-generated noise buffer for consistent noise
    const noiseBuffer = Array(1024).fill(0).map(() => Math.random() * 2 - 1);
    let noiseIndex = 0;

    function noiseWave() {
      noiseIndex = (noiseIndex + 1) % noiseBuffer.length;
      return noiseBuffer[noiseIndex];
    }

    function generateWaveform(type, phase) {
      const cacheKey = `${type}-${phase.toFixed(2)}`;
      if (!waveformCache[cacheKey]) {
        let value;
        switch(type) {
          case 0: value = sineWave(phase); break;
          case 1: value = squareWave(phase); break;
          case 2: value = sawWave(phase); break;
          case 3: value = triangleWave(phase); break;
          case 4: value = noiseWave(); break;
          default: value = sineWave(phase);
        }
        waveformCache[cacheKey] = value;
      }
      return waveformCache[cacheKey];
    }

    function calculateOscillatorValue(idx, t) {
      const prevIdx = (idx + 3) % 4;
      const prevSample = sample[prevIdx];
      const xmodAmount = (crossMod[idx] / 2000);
      const modulation = xmodAmount * prevSample;
      const effectiveFreq = freq[idx] * (1 + modulation);
      const phase = 2 * Math.PI * effectiveFreq * t + (phaseOffset[idx] * Math.PI / 180);
      return generateWaveform(waveformType[idx], phase);
    }

    function relabiWave(t) {
      let sum = 0;
      for (let i = 0; i < 4; i++) {
        if (!lfoDisable[i]) {
          sample[i] = calculateOscillatorValue(i, t);
          sum += gain[i] * sample[i];
        } else {
          sample[i] = 0;
        }
      }
      return sum;
    }

    function triggerDrum(idx, x, y) {
      if (audioMute[idx] || !audioBuffers[samples[sampleIndex[idx]]]) return;

      // Only trigger if random number is below probability threshold
      if (Math.random() * 100 > probability[idx]) return;

      const source = ctx.createBufferSource();
      source.buffer = audioBuffers[samples[sampleIndex[idx]]];
      source.connect(ctx.destination);
      source.start();

      triggerPoints[idx].push({x, y});
    }

    // Visualization
    let time = 0;
    const dt = 0.01;
    const waveData = [];
    const maxLength = 600;
    const triggerPoints = [[], [], [], []];
    let lastStates = [false, false, false, false];
    let lastDrawTime = 0;
    const drawInterval = 16; // ~60fps

    function drawWave(val) {
      const now = performance.now();
      if (now - lastDrawTime < drawInterval) return;
      lastDrawTime = now;

      waveData.push(val);
      if (waveData.length > maxLength) waveData.shift();

      waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);

      // Draw waveform
      waveCtx.beginPath();
      waveCtx.moveTo(0, 75 - waveData[0] * 15);
      for (let x = 1; x < waveData.length; x++) {
        waveCtx.lineTo(x, 75 - waveData[x] * 15);
      }
      waveCtx.strokeStyle = 'black';
      waveCtx.stroke();

      // Draw thresholds
      const topY = 75 - parseFloat(topThreshold.value) * 15;
      const botY = 75 - parseFloat(bottomThreshold.value) * 15;

      waveCtx.strokeStyle = 'lightgrey';
      waveCtx.beginPath();
      waveCtx.moveTo(0, topY);
      waveCtx.lineTo(waveCanvas.width, topY);
      waveCtx.stroke();

      waveCtx.strokeStyle = 'grey';
      waveCtx.beginPath();
      waveCtx.moveTo(0, botY);
      waveCtx.lineTo(waveCanvas.width, botY);
      waveCtx.stroke();

      // Group triggers by their x-position
      const triggerGroups = new Map();
      for (let i = 0; i < 4; i++) {
        triggerPoints[i].forEach(p => {
          const xPos = Math.floor(p.x);
          if (!triggerGroups.has(xPos)) {
            triggerGroups.set(xPos, []);
          }
          triggerGroups.get(xPos).push({
            color: drumColors[i],
            originalY: p.y // Use the recorded y position
          });
        });
      }

      // Draw all trigger points with perfect alignment
      triggerGroups.forEach((dots, xPos) => {
        // Sort by color for consistent stacking order
        dots.sort((a, b) => a.color.localeCompare(b.color));

        dots.forEach((dot, idx) => {
          let yOffset = 0;
          if (dots.length > 1) {
            // Stacking pattern:
            // 0: on line (0)
            // 1: below (-6px)
            // 2: above (+6px)
            // 3: further above (+12px)
            yOffset = [0, -6, 6, 12][idx] || 0;
          }

          waveCtx.fillStyle = dot.color;
          waveCtx.beginPath();
          waveCtx.arc(
            xPos,
            Math.round(dot.originalY) + yOffset, // Snap to pixel grid
            4,
            0,
            Math.PI * 2
          );
          waveCtx.fill();
        });
      });

      // Age out old trigger points
      for (let i = 0; i < 4; i++) {
        triggerPoints[i] = triggerPoints[i]
          .filter(p => p.x > 0)
          .map(p => ({ x: p.x - 1, y: p.y }));
      }
    }


    function initializeWaveformPreview() {
      waveData.length = 0;
      time = 0;
      noiseIndex = 0;
      for (let i = 0; i < maxLength; i++) {
        const wave = relabiWave(time);
        waveData.push(wave);
        time += dt;
      }
      drawWave(waveData[waveData.length - 1]);
    }

    // Animation loop with precise timing
    let isPlaying = false;
    let animationId = null;
    let lastFrameTime = 0;

    function loop(timestamp) {
      if (!isPlaying) return;

      if (timestamp - lastFrameTime < 16) {
              animationId = requestAnimationFrame(loop);
              return;
            }
            lastFrameTime = timestamp;

            // Direct multiplier. 1 = normal speed, 0.5 = half speed, 2 = double speed.
            const timeScale = parseFloat(globalRate.value);

            const wave = relabiWave(time);
            time += dt * timeScale;

      // Check thresholds
      const state = [
        wave > parseFloat(topThreshold.value),
        wave < parseFloat(topThreshold.value),
        wave > parseFloat(bottomThreshold.value),
        wave < parseFloat(bottomThreshold.value),
        wave > parseFloat(topThreshold.value) || wave < parseFloat(bottomThreshold.value)
      ];

      for (let i = 0; i < 4; i++) {
        if (lfoDisable[i]) continue;

        if (state[mode[i]] && !lastStates[i]) {
          triggerDrum(i, waveCanvas.width - 1, 75 - wave * 15);
        }
        lastStates[i] = state[mode[i]];
      }

      drawWave(wave);
      animationId = requestAnimationFrame(loop);
    }

    // Play/pause control
    document.getElementById('playPauseBtn').addEventListener('click', () => {
      if (ctx.state === 'suspended') {
        ctx.resume();
      }
      if (!isPlaying) {
        isPlaying = true;
        lastFrameTime = performance.now();
        animationId = requestAnimationFrame(loop);
        document.getElementById('playPauseBtn').textContent = 'Pause';
      } else {
        isPlaying = false;
        cancelAnimationFrame(animationId);
        document.getElementById('playPauseBtn').textContent = 'Play';
      }
    });

    // Randomize function
    function randomizeAll() {
      // Random speed between 0.5x and 4.0x
      globalRate.value = (Math.random() * 3.5 + 0.5).toFixed(1);
      globalRateNum.value = globalRate.value;

      topThreshold.value = (Math.random() * 4 - 2).toFixed(1);
      topThresholdNum.value = topThreshold.value;
      bottomThreshold.value = (Math.random() * 4 - 2).toFixed(1);
      bottomThresholdNum.value = bottomThreshold.value;

      if (parseFloat(bottomThreshold.value) > parseFloat(topThreshold.value)) {
        const temp = topThreshold.value;
        topThreshold.value = bottomThreshold.value;
        bottomThreshold.value = temp;
        topThresholdNum.value = topThreshold.value;
        bottomThresholdNum.value = bottomThreshold.value;
      }

      for (let i = 0; i < 4; i++) {
        freq[i] = (Math.random() * 4.95 + 0.05).toFixed(2);
        gain[i] = (Math.random() * 1.4 + 0.1).toFixed(2);
        crossMod[i] = Math.floor(Math.random() * 81);
        waveformType[i] = Math.floor(Math.random() * 5);
        mode[i] = Math.floor(Math.random() * 5);
        sampleIndex[i] = Math.floor(Math.random() * 16);
        audioMute[i] = Math.random() < 0.1;
        lfoDisable[i] = Math.random() < 0.1;
        probability[i] = Math.floor(Math.random() * 101); // Random between 0-100
      }

      buildLFOControls();
      initializeWaveformPreview();
    }

    randomizeBtn.addEventListener('click', randomizeAll);

    // Modal handling
    const helpModal = document.getElementById('helpModal');
    document.getElementById('helpButton').onclick = () => helpModal.style.display = 'block';
    document.getElementById('closeModal').onclick = () => helpModal.style.display = 'none';
    window.onclick = e => { if (e.target === helpModal) helpModal.style.display = 'none'; };

    // Initialize
    loadAudioBuffers().then(() => {
      buildLFOControls();
      initializeWaveformPreview();
    });
  </script>
</body>
</html>
